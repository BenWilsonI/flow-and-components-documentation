---
title: Handling User Events in a PolymerTemplate
order: 5
layout: page
---

ifdef::env-github[:outfilesuffix: .asciidoc]

= Handling User Events in a  Polymer Template

== Client-side Event Handlers

`PolymerTemplate` defines special syntax, `on-_eventname_="_methodName_"`, to attach client-side event handlers to elements. In addition, the method should not support any arguments or use parenthesis. You can listen to any event using this syntax: it does not matter if it is a built-in browser event, or a custom event defined a Web Component, for example.

*Example*: Wiring the `on-click` event to the `handleClick` method for a `Polymer.Element`.

[source,html]
----
<dom-module id="x-custom">
  <template>
    <button on-click="handleClick">Say hello</button>
  </template>
  <script>
    class XCustom extends Polymer.Element {

      static get is() {return 'x-custom'}

      handleClick() {
        console.log('Button was clicked.');
        window.alert('Hello');
      }
    }
    customElements.define(XCustom.is, XCustom);
  </script>
</dom-module>
----

* Clicking the button shows an alert in the browser.

== Server-Side Event Handlers

To handle a DOM event on the server side, you can create a method with the event name and annotate it with `@EventHandler`.

*Example*: Listening to the `handleClick` event on the server.

* Polymer template.
+
[source,html]
----
<dom-module id="event-handler">
  <template>
    <button on-click="handleClick">Click me</button>
  </template>
  <script>
    class EventHandler extends Polymer.Element {
      static get is() { return 'event-handler' }
    }
    customElements.define(EventHandler.is, EventHandler);
  </script>
</dom-module>
----

* Server class.
+
[source,java]
----
@Tag("event-handler")
@HtmlImport("/com/example/EventHandler.html")
public class EventHandlerPolymerTemplate extends PolymerTemplate<TemplateModel> {

    @EventHandler
    private void handleClick() {
        System.out.println("Received a handle click event");
    }
}
----
** When the `handleClick` method is detected on the `@EventHandler` annotation, the framework wires it to the client-side event. 

[NOTE]
Where there is a client-side implementation of the server event handler, the client-side method is executed before the server-side event handler method is called.

=== Adding Event Data to Server-side Events

An event can also include additional information about the event, for example which mouse button is used for a click event. 

When you use the `@EventHandler` annotation, all constructor parameters should have an `@EventData` annotation that tells the framework what data to send from the browser.

*Example*: Getting additional data about the `handleClick` event.

* Polymer template.
+
[source,html]
----
<!-- same template as for the server-side event handler -->
  <template>
    <button on-click="handleClick">Click me</button>
  </template>
----
* Server class: Using the `@EventData` annotation. 
+
[source,java]
----
@Tag("event-handler")
@HtmlImport("/com/example/EventHandler.html")
public class EventDataHandlerPolymerTemplate extends PolymerTemplate<TemplateModel> {

    @EventHandler
    private void handleClick(@EventData("event.altKey") boolean altPressed,
            @EventData("event.srcElement.tagName") String tag,
            @EventData("event.offsetX") int offsetX,
            @EventData("event.offsetY") int offsetY) {
        System.out.println("Event alt pressed: " + altPressed);
        System.out.println("Event tag: " + tag.toLowerCase(Locale.ENGLISH));
        System.out.println("Click position on element: [" + offsetX + ", "+ offsetY +"]");
    }
}
----

** The client now sends additional information to the server for `event.type`, `event.srcElement.tagName`, and the `event.offset[X/Y]` can be used like any normal variable.

[NOTE]
The server throws an exception if the `EventData` can not be converted to the given format. For example, you could get the `java.lang.ClassCastException: Cannot cast elemental.json.impl.JreJsonNumber to elemental.json.JsonObject` exception. In addition, the client may throw an exception if the value given for `EventData` cannot be executed or converted to Json.

=== Using Shorthand for Model-specific Items

If your model uses beans in the template class, you can use shorthand to get model-specific items as an object in your event handler. 

*Example*: Using shorthand to get model-specific items as an object.

* Server class.
+
[source,java]
----
@Tag("model-item-handler")
@HtmlImport("/com/example/ModelItemHandler.html")
public class ModelItemHandlerPolymerTemplate
            extends PolymerTemplate<MessagesModel> {

    public static class Message {
        private String text;

        public Message() {
        }

        public Message(String text) {
            this.text = text;
        }

        public String getText() {
            return text;
        }

        public void setText(String text) {
            this.text = text;
        }
    }

    public interface MessagesModel extends TemplateModel {
        void setMessages(List<Message> messages);
    }

    @EventHandler
    private void handleClick(@ModelItem Message message) {
        System.out.println("Received a message: " + message.getText());
    }
}
----
* Polymer template: Using the template repeater shorthand (`<dom-repeat>`) and `handleClick` event on the server side with `Message` as the parameter type.
+

[source,html]
----
<dom-module id="model-item-handler">
    <template>
    <dom-repeat items="[[messages]]">
      <template><div class='msg' on-click="handleClick">[[item.text]]</div></template>
    </dom-repeat>
  </template>
  <script>
    class ModelItemHandler extends Polymer.Element {
      static get is() { return 'model-item-handler' }
    }
    customElements.define(ModelItemHandler.is, ModelItemHandler);
  </script>
</dom-module>
----

** The `handleClick` method is called on the server side when the data identified by `event.model.item` is clicked. 

=== Keeping Model Data in Sync

You can use the `@ModelItem` annotation with any provided value as a data path. By default the data path is `event.model.item`. You should declare your data type in the model definition and reference it from the model.

The `@ModelItem` annotation is just a convenient way to access model data. The argument you receive in your event handler callback, is the *model data* from the server side that you can access directly via your model instance. The server does not update the model item from the client in any event. So, if you create a custom event on the client side with data that you want to send to the server as a model item, it is completely ignored on the server side, and the current model data is used instead. You always should keep your model in sync on the server and client sides, by correctly updating it.

*Example*: This first demonstrates how NOT to update the `UserInfo` bean instance, and then provides instructions to correct the situation.

* Server class: Model definition and event handler method. 
+
[source,java]
----
    public static class UserInfo {
        private String name;

        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
    }

    public interface Model extends TemplateModel {
        void setUserInfo(UserInfo userInfo);
    }

    @EventHandler
    private void onClick(
            @ModelItem("event.detail.userInfo") UserInfo userInfo) {
        System.err.println("contact : name = " + userInfo.getName());
    }
----

* Polymer template: This client-side code DOES NOT update the name of the `UserInfo` bean instance.
+
[source,html]
----
<dom-module id="contact-handler">
    <template>
        <input id="name" type="text">
        <button on-click="onClick">Send the contact</button>
    </template>
</dom-module>

<script>
class ContactHandler extends Polymer.Element {
      static get is() { return 'contact-handler' }

        onClick(event) {
            this.userInfo.name = this.$.name.value;
            event.detail = {
                userInfo: this.userInfo,
        };
    }
    customElements.define(ContactHandler.is, ContactHandler);
</script>
}
----
** In this example, the server-side model becomes desynchronized with the client side, because the client-side model is updated incorrectly.
** The correct way to update subproperties in the Polymer template is to replace the line, `this.userInfo.name = this.$.name.value`, with `this.set("userInfo.name", this.$.name.value)`. However, in this case the server-side model is updated automatically for
you and there is no need to send this custom event at all. You should, however, notify the server somehow about the click event, for example. via `this.$server` and a `@ClientCallable` method. See <<tutorial-template-basic#,Creating A Simple Component Using the PolymerTemplate API>> for how to get the model value directly from the server-side model.

See the following related resources for more:

* <<tutorial-template-list-bindings#,Using a List of Items in a PolymerTemplate with Template Repeater>>. 

* <<tutorial-template-model-bean#,Using Beans with a PolymerTemplate Model>>.
