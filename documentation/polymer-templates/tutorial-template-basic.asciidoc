---
title: Creating a Simple Component Using the PolymerTemplate API
order: 1
layout: page
---

= Creating a Simple Component Using the PolymerTemplate API

In this section, we demonstrate how to use the `PolymerTemplate` API to create a simple component. 

Our example uses only a Polymer template, but it is also possible to create complex components using Polymer templates in conjunction with elements and components.

We create a component with one input field for the user's name. The name is used to print a personalized greeting when the user clicks a button. 

[NOTE]
The code used in the demo is based on the https://github.com/vaadin/flow-demo/tree/master/demo-hello-worlds[`demo-hello-worlds`] technical demo that shows three ways to achieve the same result: using components, the `Element` API and the `PolymerTemplate` API. 

Vaadin Flow uses Polymer 2 and this demo assumes you are familiar with standard Polymer features. See the https://www.polymer-project.org/2.0/docs/about_20[Polymer 2 documentation] to learn more.

To create a Polymer component:

. On the client side, create a Polymer template in HTML. 
+
*Example*: `HelloWorld` Polymer template. 
+
[source,html]
----
<!-- Dependency resources -->
<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/paper-input/paper-input.html">

<!-- Defines the hello-world element -->
<dom-module id="hello-world">
    <template>
        <!-- Input element that updates the name property in the model -->
        <paper-input id="inputId" value="{{name}}" style="width: 200px"></paper-input>
        <!-- Input element that shows the greeting from the model -->
        <div id="greeting">[[greeting]]</div>
    </template>
    
    <!-- Polymer boilerplate to register the hello-world element -->
    <script>
        class HelloWorld extends Polymer.Element {
            static get is() {
                return 'hello-world'
            }
        }
        customElements.define(HelloWorld.is, HelloWorld);
    </script>
</dom-module>
----
* Two dependencies are imported from the Polymer 2 library:
** `polymer-element.html` is required to ensure correct functionality. You may need to install Polymer 2 (see below).
** https://github.com/PolymerElements/paper-input.com[`paper-input.html`] is the imported Web Component. This template file must be available via URL.  
* To comply with Polymer syntax rules, the following names must have at least one dash (`-`):
** Template tag name (`hello-world`) defined in the `id` attribute of the `<dom-module>` element.
** The return of the `is()` function (`hello-world`).
* There are two bindings:
** `\[[greeting]]` is a one-way binding (annotated with double square bracket delimiters).
** `{{name}}` is a two-way binding (annotated with double curly bracket delimiters). 
* `<script>` class is the basic declaration for a Polymer element.
* No model is specified. It is propagated automatically from the server side (see 3. below). 
+
[NOTE]
To get `polymer-element.html` into your project, you can install Polymer 2 from Bower or use the Polymer CLI (see https://www.polymer-project.org/2.0/start/install-2-0[Polymer 2 documentation] for instructions) or you can use a Maven plugin, such as https://github.com/eirslett/frontend-maven-plugin[`frontend-maven-plugin`].

. On the server side, create a matching Java class that extends `PolymerTemplate` and imports the HTML template created in the previous step.
+
*Example*: `HelloWorldTemplate` Java class.
+
[source,java]
----
@Tag("hello-world")
@HtmlImport("src/HelloWorld.html")
@PageTitle("Hello World with a template")
@Route(value = "template", layout = MainLayout.class)
public class HelloWorldTemplate extends PolymerTemplate<HelloWorldModel> {

    /**
     * Template constructor.
     */
    public HelloWorldTemplate() {
        // Set the initial greeting value
        updateGreeting();

        // Listen for value change events. The name property is updated by logic
        // in the template.
        getElement().addPropertyChangeListener("name",
                event -> updateGreeting());

        // Set up a DOM id value used for integration tests
        setId("template");
    }

    private void updateGreeting() {
        String name = getModel().getName();

        // Update the model based on the name
        if (name == null || name.isEmpty()) {
            getModel().setGreeting("Please enter your name");
        } else {
            getModel().setGreeting(String.format("Hello %s!", name));
        }
    }
}
----
* The `"hello-world"` attribute in the `@Tag` annotation must match the `"id"` attribute in the `<dom-module>` element in the HTML template.  
* The `@HtmlImport` annotation specifies the path to the Polymer template, `src/HelloWorld.html`, binding the Java class and the template. 
* The `getElement().addPropertyChangeListener` method..... 
* The `setId` .....
* ......
+
[NOTE]
The Java class name and Polymer template file name do not need to match. The template file is just another resource file that you can store in any location, but it is important that it is accessible via the URL. 

. Add a model to the Java class. The model defines the properties passed to the HTML template.
+
*Example*: Adding a model to the `HelloWorldTemplate` Java class.
+
[source,java]
----
/**
     * A model interface that defined the data that is communicated between the
     * server and the client.
     */
    public interface HelloWorldModel extends TemplateModel {
        /**
         * The name shown in the input is updated from the client.
         * 
         * @return current name in model
         */
        String getName();

        /**
         * The greeting is updated from Java code on the server.
         * 
         * @param greeting
         *            greeting to set to the model
         */
        void setGreeting(String greeting);
    }
----
* The model is a simple Java interface that extends the `TemplateModel` class and has getter and/or setter methods for properties.
* The model can be accessed via the `getModel()` method, provided it is specified as a generic type of `PolymerTemplate` class.


[NOTE]
An alternative way to call a server-side method is to use the `@ClientCallable` annotation. This marks a template method as the method to be called from the client side code, when the notation `this.$server.serverMethodName(args)` is used. Use it in your client-side Polymer class implementation and pass your own arguments in the method. Be sure to check that the types used match the method declaration on the server side.

== Executing Logic After Server Updates

The `afterServerUpdate` method allows you to execute logic on the client side after a component is updated from the server during a round trip. This method is called each time the component is updated on the server side.

*Example*: Using the `afterServerUpdate` method in a Polymer template.

[source,html]
----
<link rel="import" href="../bower_components/polymer/polymer-element.html">

<dom-module id="my-component">
    <template>
        <div>
            <div>[[text]]</div>
        </div>
    </template>
    <script>
        class MyComponent extends Polymer.Element {
            static get is() {
                return 'my-component'
            }

            afterServerUpdate(){
                console.log("The new 'text' value is: "+this.text);
            }
        }
        customElements.define(MyComponent.is, MyComponent);
    </script>
</dom-module>
----

== Using Polymer Components

You can use Polymer template components in the same way as any other component.

*Example*: Using the `HelloWorld` component

[source,java]
----
HelloWorld hello = new HelloWorld();

Div layout = new Div();
layout.add(hello);
----

[NOTE]
You can to configure the `vaadin-maven-plugin` in your `pom.xml` to support non-ES6 browsers, like IE 11 and Safari 9. See <<../production/tutorial-production-mode-basic#,Taking your Application into Production>> for more.
