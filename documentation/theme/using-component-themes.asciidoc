---
title: Using Themes
order: 2
layout: page
---

= Using Themes 

A theme is a set of shared styles, like fonts and colors, that Vaadin Flow loads to the initial page.

The theme class tells Vaadin Flow which theme to apply and where the theme files are located.

*Example*: Import section of the `Lumo.java` theme class.

[source,java]
----
@HtmlImport("frontend://bower_components/vaadin-lumo-styles/color.html")
@HtmlImport("frontend://bower_components/vaadin-lumo-styles/typography.html")
@HtmlImport("frontend://bower_components/vaadin-lumo-styles/sizing.html")
@HtmlImport("frontend://bower_components/vaadin-lumo-styles/spacing.html")
@HtmlImport("frontend://bower_components/vaadin-lumo-styles/style.html")
@HtmlImport("frontend://bower_components/vaadin-lumo-styles/icons.html")
public class Lumo implements AbstractTheme {
----

Vaadin Flow typically ships with two themes, https://vaadin.com/themes/lumo[Lumo] and https://vaadin.com/themes/material[Material]. In most cases, the Lumo theme is enabled by default, and applied to your application and its components, unless you specify that it should not be.  

== Theme Resolving Order

Vaadin Flow applies the following logic, in the following resolving order, to determine which theme to use in your application:

. If the `@Theme` annotation is found at the <<../routing/tutorial-routing-annotation#,root navigation>> level, the theme set in the annotation is used. See <<Applying a Theme>> for more.
. If the `@NoTheme` annotation is found at the root navigation level, theming is disabled. See <<Disabling Themes>> for more. 
. If the `com.vaadin.flow.theme.lumo.Lumo` class is available in the classpath, the default Lumo theme is used.

When a match is found, resolving stops. If none of the conditions are met, no theme is used. This means that projects that use the `vaadin-core` dependency, use the Lumo theme by default, unless you declare an `@Theme` or `@NoTheme`. 


== Applying a Theme

To apply a theme, add the `@Theme` annotation to any of the following:

* Root navigation level.
+
*Example*: Using the `@Theme` annotation at the root navigation level.
+
[source,java]
----
 @Route(value = "")
 @Theme(MyTheme.class)
 public class Main extends Div {
 }
----

* `RouterLayout`.
+
*Example*: Using the `@Theme` annotation for a `RouterLayout`.
+
[source,java]
----
 @Theme(MyTheme.class)
 public class MainLayout extends Div implements RouterLayout {
 }

 @Route(value = "editor", layout = MainLayout.class)
 public class Editor extends Div {
 }
----
* Top-level `@Route` annotation.
+
*Example*: Using the `@Theme` annotation for a `RouterLayout` with a navigation hierarchy.
+
[source,java]
----
@Theme(MyTheme.class)
public class MainLayout extends Div implements RouterLayout {
}

@Route(value = "", layout = MainLayout.class)
public class HomeView extends Div {
}

@Route(value = "blog", layout = MainLayout.class)
public class BlogPost extends Div {
}
----

[NOTE]
If the `@Theme` annotation is not on a `@Route` component or top-level `RouterLayout`, an exception is thrown on startup.

[NOTE]
It is technically possible to define a different theme for each `RouterLayout`, but this is not recommended. If you have good reason to use more than one theme in the same application, do so with caution, because bootstrap additions can cause theme conflicts and unwanted consequences. 

== Disabling Themes

You can use the `@NoTheme` annotation to disable themes completely. 

*Example*: Using the `@NoTheme` annotation.

[source,java]
----
@Route(value = "")
@NoTheme
public class UnThemedApplication extends Div {
}
----


== Using Theme Variants

A theme variant is a variation of the visual appearance of a component. 

The Lumo and Material themes come with two global variants: light (default) and dark. 

Themes can have different types of variants: 

* *Global* variants apply globally throughout the application.
* *Component* variants apply only to specific components. 

A variant is a special string value that can be used as a `theme` attribute value in any HTML element, when the corresponding theme is enabled. 

*Example*: HTML representation of a variant.
[source,html]
----
<vaadin-button theme="contrast primary">Themed button</vaadin-button>
----

You can apply multiple variants to the same element by separating them with white spaces. 

=== Using Global Theme Variants

You can set a global theme variant by defining it on the `@Theme` annotation.

*Example*: Setting the `large` theme variant. 
[source,java]
----
@Route(value = "")
@Theme(value = MyTheme.class, variant = "large")
public class LargeThemedApplication extends Div {
}
----

Theme variants are not used by the Lumo or Material themes, by default. You can set the dark variant for either theme by defining it in the `@Theme` annotation.

*Example*: Setting the dark variant for the Lumo theme. 

[source,java]
----
@Route(value = "")
@Theme(value = Lumo.class, variant = Lumo.DARK)
public class DarkApplication extends Div {
}
----

*Example*: Setting the dark variant for the Material theme. 

[source,java]
----
@Route(value = "")
@Theme(value = Material.class, variant = Material.DARK)
public class DarkMaterialApplication extends Div {
}
----

=== Using Component Theme Variants

Variants are also available for individual components. Each theme provides a predefined set of variants that you can use. There are different variants for different components, and some components have no variants. 

Available component variants are applied using the `Element` API to set the variant as the `theme` attribute.

Variants are converted to their equivalent HTML value. For example, the `ButtonVariant.LUMO_PRIMARY.getVariantName()` method is used to convert a button variant to HTML. After conversion, the HTML representation is added as the `theme` attribute value. 

All components that implement the `HasTheme` interface have an `addThemeVariants` method that you can use.

The following three examples all achieve the same result. They demonstrate different ways to add `contrast` and `primary` Lumo theme variants to the `theme` attribute value of the button component:

* *Example*: Using the `addThemeVariants` method to add theme variants for the `Button` component. 
+
[source,java]
----
Button button = new Button("Themed button");
        button.addThemeVariants(ButtonVariant.LUMO_PRIMARY,
                ButtonVariant.LUMO_CONTRAST);
----


* *Example*: Using the `getThemeNames().addAll` method to add an array of theme variants to the `Button` component. 
+
[source,java]
----
Button button = new Button("Themed button");
button.getThemeNames().addAll(Arrays.asList("contrast", "primary"));
----


* *Example*: Adding variants to the `theme` attribute of the `Button` component by manipulating the `theme` attribute.
+
[source,java]
----
Button button = new Button("Themed button");
        String themeAttributeName = "theme";
        String oldValue = button.getElement().getAttribute(themeAttributeName);
        String variantsToAdd = "contrast primary";
        button.getElement().setAttribute(themeAttributeName,
                oldValue == null || oldValue.isEmpty() ? variantsToAdd
                        : ' ' + variantsToAdd);
----
** This example provides more flexibility. It allows you to manipulate the value of the `theme` attribute directly. This is useful when adding non-standard theme variants to a component.

[NOTE]
Component theme variants only work if the corresponding theme is <<Applying a Theme,enabled>>. If a different theme or no theme is enabled, variants in the `theme` attribute have no effect on the look and feel of the component.


=== Using Theme Presets

The Lumo theme include a https://cdn.vaadin.com/vaadin-lumo-styles/1.4.1/demo/sizing-and-spacing.html#compact-preset[compact preset] that defines values for sizing and spacing properties. This preset reduces the visual space required by components and allows you to fit more content on the screen. You need to import `compact.html` to use this preset. 

*Example*: Using the `@HtmlImport` annotation to import the compact preset on a `RouterLayout`.

[source,java]
----
@HtmlImport("frontend://bower_components/vaadin-lumo-styles/presets/compact.html")
@Theme(Lumo.class)
public class CompactMainLayout extends Div implements RouterLayout {
}
----

== Customizing Prebuilt Themes

You can use either of the prebuilt themes (Lumo or Material) as the starting point to build your own custom theme. Both themes are included as `vaadin-core` dependencies. 

The prebuilt themes have comprehensive documentation and provide customization points that allow you to fine tune the look and feel of your application. See the Customization section of the https://vaadin.com/themes/lumo[Lumo] and https://vaadin.com/themes/material[Material] documentation for how to use CSS custom properties. 

Theming of the Vaadin components is built using `Vaadin.ThemableMixin`.
See https://github.com/vaadin/vaadin-themable-mixin/wiki[vaadin-themable-mixin] for more.
