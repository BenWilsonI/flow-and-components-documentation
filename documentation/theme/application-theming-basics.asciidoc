---
title: Application Theming Basics
order: 3
layout: page
---

= Application Theming Basics

Theming ensures that an application has a consistent and professional look and feel throughout. 

The content in this section focuses on theming a single application, i.e. specifying styles that apply to one application. 

[NOTE]
If you want to share styles across multiple applications, the best practice is to create a dedicated theming module that can be shared as a dependency by multiple applications. 

== Application Theming Approaches

Most developers use a prebuilt Vaadin theme, such as https://vaadin.com/themes/lumo[Lumo] or https://vaadin.com/themes/material[Material], as the starting point to customize styling in their application. See <<using-component-themes#customizing-prebuilt-themes,Customizing Prebuilt Themes>> for more. 

[NOTE]
The Material theme is fully compliant with Googleâ€™s https://material.io/[Material Design guidelines].

When starting with a prebuilt theme, you can follow either of the following approaches: 

* Use the default Lumo theme and only add styling to customize the shadow DOM of specific components. 
** Specifically, this means you:
*** Do not use the `@Theme` annotation. The Lumo theme is used by default, as long as it exists in your classpath.
*** Import only component-specific CSS to style the shadow DOM of the components you want to customize. 
** *Advantages*: This is the fastest and simplest approach.  


* Use a custom theme class. 
** Specifically, this means you:
*** Use the `@Theme` annotation to specify your custom theme class, for example `MyTheme.class`. See <<integrating-component-theme#,Creating a Custom Theme>> for more.
*** Define imports in the theme class for global HTML files and the path from which to load the <<theming-crash-course#using-style-modules,style modules>>. The imports are replacements for Lumo implementations for Vaadin components.
** *Advantages*: 
*** You can select and customize only the Lumo styles that you need to load for each component. This reduces the number of styles loaded and gives you more control. 
*** You can achieve better encapsulation of the custom component stying.
** *Disadvantages*: It is necessary to create an HTML file for every Vaadin component that you want the custom theme class to support. 

[NOTE]
Lumo only loads the styles for the components that you use. 

== Theming File Types and File Storage

The only way to style <<../polymer-templates/tutorial-template-basic#,Polymer components>> is to include the CSS styles in an HTML file. While it is possible to style other components using pure CSS, the prebuilt Vaadin themes use HTML files that are suitable for all components. 

We recommend that you name your application-wide styles `shared-styles.html` and store them in the `/frontend/styles` folder (full path: `src/main/webapp/frontend/styles/shared-styles.html`). You should include all global and view-specific styles in this file. 

You can import `shared-styles.html` using the `@HtmlImport` annotation. For CSS files, you can use the `@StyleSheet` annotation. See <<../importing-dependencies/tutorial-include-css#,Including Style Sheets>> and <<../importing-dependencies/tutorial-importing#,Importing HTML and JavaScript>> for more. 

*Example*: Using the `@HtmlImport` annotation to import `shared-styles.html`.  
[source,java]
----
@HtmlImport("frontend://styles/shared-styles.html")
@Viewport("width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes")
public class MainLayout extends Div implements RouterLayout {
}
----

For Polymer components, you can also include your styles directly in the HTML Polymer template file. This makes it easier to develop stand-alone, reusable and distributable components. See <<theming-crash-course#applying-scoped-styles,Applying Scoped Styles>> for more. 


== Polymer Component Styling Issues

Regardless of the approach you follow, Polymer components can be problematic, because there is no guarantee that component-specific styles will override global styles. See <<../importing-dependencies/tutorial-ways-of-importing#dependency-loading-order,Dependency Loading Order>> for more. 

The main reason for this issue is the way Polymer 2 makes DOM modules available for browser-CSS evaluation.  
 
The only workaround is to declare CSS rules for Polymer components with greater specificity than the global properties you want to override. 

Note that attempting to increase the specificity of a CSS rule using `:host(vaadin-button)`, for example, does not generally change the selection in any way, because the `theme-for` attribute probably already limits the styles to `vaadin-button`.

[NOTE]
`:host(vaadin-button)` works in Chrome, but does not work in browsers that need shimming, for example Firefox 62.

[NOTE]
You can use the `:host` pseudo-class selector to target styles in the element that hosts the component, but not elements inside the Polymer template.  

Depending on the component, there are also other ways to increase specificity. For example, you can use `:host([tabindex])`, as all buttons have a `tabindex`. This works in all supported browsers, but not for all components.

Increasing the specificity of the CSS rules also has disadvantages in that it requires that you implement the component. 

Another alternative is to use `!important` to override global styles. This is the only method that currently works for all browsers and components.

*Example*: Using `!important` to increase the specificity of a CSS selector.

[source,html]
----
<dom-module id="my-grid-theme" theme-for="vaadin-grid">
    <template>
        <style>
            [part~="cell"] ::slotted(vaadin-grid-cell-content) {
                padding: 5px !important;
            }
        </style>
    </template>
</dom-module>
----

See the following related documentation for more:  

* <<theming-crash-course#styling-polymer-components,Theming Polymer Components>>.
* https://vaadin.recipes/styling-internals-of-a-vaadin-component/[Styling Internals of a Vaadin component] for a tutorial on styling Polymer components. 
